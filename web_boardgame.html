<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Boardgame — Prototype</title>
  <style>
    /* -------------------------
       Reset + Base
    ----------------------------*/
    :root{
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #9aa4b2;
      --accent: #00d1b2;
      --accent-2: #6ea8fe;
      --glass: rgba(255,255,255,0.03);
      --rounded: 12px;
      --glass-2: rgba(255,255,255,0.02);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* ---------- styles only here; JS moved to <script> ---------- */

    *{box-sizing:border-box;}
    html,body{height:100%}
    body{
      margin:0;
      background: linear-gradient(180deg,#071022 0%, #071830 60%), var(--bg);
      color:#e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:24px;
    }
    .container{
      max-width:1100px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:20px;
      align-items:start;
    }
    header{
      grid-column:1 / -1;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:16px;
      margin-bottom:8px;
    }
    .logo{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .logo .mark{
      width:44px;height:44px;border-radius:10px;
      background:linear-gradient(135deg,var(--accent),var(--accent-2));
      display:flex;align-items:center;justify-content:center;font-weight:700;color:#042;
      box-shadow:0 6px 18px rgba(0,0,0,0.6);
    }
    h1{font-size:18px;margin:0}
    .profile{
      background:var(--glass);
      padding:10px 12px;border-radius:10px;display:flex;gap:12px;align-items:center;
    }
    .avatar{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,#0ea5a4,#60a5fa);display:flex;align-items:center;justify-content:center;font-weight:700}
    .stat{font-size:13px;color:var(--muted)}
    /* Left column: main area */
    .main{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:18px;border-radius:14px;min-height:520px;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6);
    }
    .games-grid{
      display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px;
    }
    .game-card{
      background:var(--card);padding:14px;border-radius:12px;cursor:pointer;
      display:flex;flex-direction:column;gap:8px;align-items:flex-start;transition:transform .14s, box-shadow .14s;
      border:1px solid rgba(255,255,255,0.02);
    }
    .game-card img.game-img {
      width: 100%;
      height: 120px;
      object-fit: cover;
      border-radius: 8px;
      margin-bottom: 6px;
    }

    .game-card:hover{transform:translateY(-6px);box-shadow:0 10px 30px rgba(2,8,20,0.5)}
    .game-title{font-weight:700}
    .game-meta{font-size:13px;color:var(--muted)}
    .controls{margin-top:14px;display:flex;gap:8px;align-items:center}
    .btn{
      background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#042;border:none;padding:10px 12px;border-radius:10px;font-weight:700;cursor:pointer;
      box-shadow:0 6px 18px rgba(3,6,25,0.6);
    }
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);font-weight:600}
    /* Right column: side panel */
    .panel{
      background:var(--glass-2);padding:16px;border-radius:12px;min-height:520px;
    }
    .panel h3{margin:0 0 8px 0}
    .stats{
      display:flex;flex-direction:column;gap:8px;
    }
    .stat-row{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .rooms{margin-top:12px;display:flex;flex-direction:column;gap:8px}
    .room{padding:8px;border-radius:8px;background:linear-gradient(0deg, rgba(255,255,255,0.01), transparent);display:flex;justify-content:space-between;align-items:center}
    .small{font-size:13px;color:var(--muted)}
    /* Views */
    .view{display:none}
    .view.active{display:block}
    /* Lobby / board area full width modal-ish */
    .overlay{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(2,6,23,0.6);backdrop-filter: blur(2px);
    }
    .panel-modal{
      width:920px;max-width:96%;background:linear-gradient(180deg,#071022,#06121b);padding:18px;border-radius:14px;border:1px solid rgba(255,255,255,0.03)
    }
    .lobby-players{display:flex;gap:12px;align-items:center;margin:10px 0}
    .player-pill{background:var(--card);padding:8px 10px;border-radius:999px;font-weight:600}
    /* TicTacToe board */
    .board{
      display:grid;
      grid-template-columns: repeat(3, 120px);
      grid-template-rows: repeat(3, 120px);
      gap:10px;
      justify-content:center;
      margin:14px 0;
    }
    .cell{
      width:120px;height:120px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      display:flex;align-items:center;justify-content:center;font-size:44px;font-weight:800;color:#e6eef6;cursor:pointer;
      transition:transform .08s, box-shadow .08s;
    }
    .cell:hover{transform:translateY(-4px)}
    .meta{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    /* small-screen adjustments */
    @media (max-width:960px){
      .container{grid-template-columns:1fr; padding:12px}
      .games-grid{grid-template-columns:repeat(2,1fr)}
      .board{grid-template-columns: repeat(3, 90px); grid-template-rows: repeat(3, 90px)}
      .cell{width:90px;height:90px;font-size:34px}
    }
    @media (max-width:560px){
      .games-grid{grid-template-columns:repeat(1,1fr)}
    }
    /* footer */
    footer{grid-column:1/-1;margin-top:12px;color:var(--muted);font-size:13px;text-align:center}
    /* tiny helpers */
    .muted{color:var(--muted)}
    .flex{display:flex;gap:8px;align-items:center}
    .center{text-align:center}
    .pill{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:700}
    .hidden{display:none}

    /* make selects readable on dark background */
    .panel-modal select,
    .panel-modal select option,
    select,
    select option {
      color: #e6eef6 !important;
       background-color: #071022 !important;
      background-image: none !important;
      border-color: rgba(255,255,255,0.04) !important;
    }
    .panel-modal select option,
    select option {
      padding: 6px 10px;
      color: #e6eef6 !important;
      background-color: #071022 !important;
    }
    .panel-modal select {
      -webkit-appearance: none;
      appearance: none;
      padding-right: 28px;
      outline: none;
      box-shadow: none;
    }
    .panel-modal select:focus {
      box-shadow: 0 0 0 3px rgba(0,209,178,0.08);
    }
    select::-ms-expand { display: none; }
    .panel-modal select {
      -webkit-appearance: none;
      appearance: none;
      padding-right: 28px;
    }
    .panel-modal select option { text-align: left; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">
        <div class="mark">WB</div>
        <div>
          <h1>Web Boardgame — Prototype</h1>
          <div class="small muted">Chọn 1–6 game · Chơi vs AI hoặc người</div>
        </div>
      </div>

      <div class="profile">
        <div class="avatar" id="avatar">U</div>
        <div>
          <div id="username">User123</div>
          <div class="small stat" id="user-stats">Win: 0 • Lose: 0</div>
        </div>
      </div>
    </header>

    <!-- Main -->
    <main class="main">
      <!-- Home / Game selection view -->
      <section id="home-view" class="view active">
        <h2>Chọn boardgame</h2>
        <div class="games-grid" id="gamesGrid">
          <!-- Game cards created by JS for flexibility -->
        </div>

        <div class="controls">
          <button class="btn" id="quickPlayBtn">Chơi nhanh (AI)</button>
          <button class="btn ghost" id="createRoomBtn">Tạo phòng</button>
          <button class="btn ghost" id="statsBtn">Xem thống kê</button>
        </div>
      </section>

      <!-- Room Lobby / Game screen placeholder -->
      <section id="game-view" class="view">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <button class="btn ghost" id="backToHomeBtn">← Quay lại</button>
          </div>
          <div class="meta">
            <div class="pill" id="currentGameLabel">Game</div>
            <div class="small muted" id="turnLabel">Lượt:</div>
          </div>
        </div>

        <div id="lobbyArea" style="margin-top:12px">
          <!-- Lobby or board will be inserted here -->
        </div>
      </section>

      <!-- Stats view -->
      <section id="stats-view" class="view">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <h2>Thống kê</h2>
          <button class="btn ghost" onclick="showView('home')">← Quay lại</button>
        </div>

        <div class="stats" id="statsList">
          <!-- Filled by JS -->
        </div>
        <div style="margin-top:12px">
          <button class="btn ghost" id="clearStatsBtn">Xoá thống kê</button>
        </div>
      </section>
    </main>

    <!-- Right panel -->
    <aside class="panel">
      <h3>Thông tin nhanh</h3>
      <div class="stat-row">
        <div><strong id="totalGames">0</strong><div class="small muted">Trận đã chơi</div></div>
        <div><strong id="winRate">0%</strong><div class="small muted">Tỷ lệ thắng</div></div>
      </div>

      <h3 style="margin-top:12px">Phòng đang chờ</h3>
      <div class="rooms" id="roomsList">
        <!-- JS rooms list -->
      </div>

      <h3 style="margin-top:12px">Gợi ý</h3>
      <div class="small muted">Bạn có thể nhấn "Chơi nhanh" để thử TicTacToe vs AI, hoặc tạo phòng để mời bạn bè (mã phòng chỉ local demo).</div>
    </aside>

    <footer>Prototype — mở rộng dễ dàng sang React/Socket.io. (Local demo lưu stats bằng localStorage)</footer>
  </div>

  <!-- Overlay modal templates -->
  <div id="overlayRoot" class="hidden"></div>

  <script>
    /* ===========================
       Frontend logic (vanilla)
       - Game list & UI navigation
       - Simple room system (local demo)
       - TicTacToe playable vs AI (minimax) or 2-player
       - Stats stored in localStorage
    ==============================*/

    /* --------- Data & helpers ---------- */
    const GAMES = [
  { id:'tictactoe', name:'Tic Tac Toe', desc:'3×3, nhanh gọn', players:2,
    img: './assets/images/placeholder.png' },

  { id:'connect4', name:'Connect 4', desc:'4 in a row', players:2,
    img: './assets/images/placeholder.png' },

  { id:'reversi', name:'Reversi', desc:'Lật đĩa', players:2,
    img: './assets/images/placeholder.png' },

  { id:'chessmini', name:'Chess Mini', desc:'Cờ vua nhỏ (coming soon)', players:2,
    img: './assets/images/placeholder.png' },

  { id:'coganh', name:'Cờ Gánh', desc:'Truyền thống (coming soon)', players:2,
    img: './assets/images/placeholder.png' },

  { id:'uno', name:'Uno Mini', desc:'Bài đơn giản (coming soon)', players:2,
    img: './assets/images/placeholder.png' }
];


    const root = {
      homeView: document.getElementById('home-view'),
      gameView: document.getElementById('game-view'),
      statsView: document.getElementById('stats-view'),
      gamesGrid: document.getElementById('gamesGrid'),
      lobbyArea: document.getElementById('lobbyArea'),
      overlayRoot: document.getElementById('overlayRoot'),
      roomsList: document.getElementById('roomsList'),
      statsList: document.getElementById('statsList'),
      usernameEl: document.getElementById('username'),
      userStatsEl: document.getElementById('user-stats'),
      totalGamesEl: document.getElementById('totalGames'),
      winRateEl: document.getElementById('winRate'),
      currentGameLabel: document.getElementById('currentGameLabel'),
      turnLabel: document.getElementById('turnLabel'),
      avatarEl: document.getElementById('avatar')
    };

    /* ---------- Local persistence (very simple) ---------- */
    const STORAGE_KEY = 'wb_proto_stats_v1';
    function loadStats(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : { total:0, wins:{}, losses:{}, draws:{} };
      }catch(e){return { total:0, wins:{}, losses:{}, draws:{} };}
    }
    function saveStats(st){ localStorage.setItem(STORAGE_KEY, JSON.stringify(st)); }
    let STATS = loadStats();

    function recordResult(gameId, result) {
      // result: 'win' | 'lose' | 'draw'
      STATS.total = (STATS.total || 0) + 1;
      STATS.wins[gameId] = STATS.wins[gameId] || 0;
      STATS.losses[gameId] = STATS.losses[gameId] || 0;
      STATS.draws[gameId] = STATS.draws[gameId] || 0;
      if(result === 'win') STATS.wins[gameId] += 1;
      else if(result === 'lose') STATS.losses[gameId] += 1;
      else STATS.draws[gameId] += 1;
      saveStats(STATS);
      refreshHeaderStats();
    }

    function clearStats(){
      STATS = { total:0, wins:{}, losses:{}, draws:{} };
      saveStats(STATS);
      renderStatsView();
      refreshHeaderStats();
    }

    /* ---------- UI util ---------- */
    function showView(name){
      root.homeView.classList.remove('active');
      root.gameView.classList.remove('active');
      root.statsView.classList.remove('active');
      if(name === 'home') root.homeView.classList.add('active');
      if(name === 'game') root.gameView.classList.add('active');
      if(name === 'stats') root.statsView.classList.add('active');
    }

    function genId(len=5){
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let s=''; for(let i=0;i<len;i++) s+=chars[Math.floor(Math.random()*chars.length)];
      return s;
    }

    /* ---------- Rooms (local demo) ---------- */
    const ROOMS = {};
    function createRoom(gameId, hostName){
      const id = genId(5);
      ROOMS[id] = { id, gameId, host:hostName, players:[hostName], created:Date.now() };
      renderRooms();
      return ROOMS[id];
    }
    function joinRoom(id, playerName){
      if(!ROOMS[id]) return false;
      if(ROOMS[id].players.length < 2) ROOMS[id].players.push(playerName);
      renderRooms();
      return true;
    }
    function renderRooms(){
      root.roomsList.innerHTML = '';
      const keys = Object.keys(ROOMS);
      if(keys.length === 0){
        root.roomsList.innerHTML = `<div class="small muted">Chưa có phòng. Tạo phòng để mời bạn bè (demo local)</div>`;
        return;
      }
      keys.forEach(k=>{
        const r = ROOMS[k];
        const el = document.createElement('div');
        el.className = 'room';
        el.innerHTML = `<div>
          <div style="font-weight:700">${r.gameId} · #${r.id}</div>
          <div class="small muted">${r.players.length}/2 người</div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn ghost" onclick="openRoom('${r.id}')">Mở</button>
          <button class="btn ghost" onclick="promptJoin('${r.id}')">Tham gia</button>
        </div>`;
        root.roomsList.appendChild(el);
      });
    }

    /* ---------- Render game cards ---------- */
    function renderGameCards(){
      root.gamesGrid.innerHTML = '';
      GAMES.forEach(g => {
        const card = document.createElement('div');
        card.className = 'game-card';
        card.innerHTML = `
          <img src="${g.img}" class="game-img">
          <div class="game-title">${g.name}</div>
          <div class="game-meta">${g.desc}</div>

          <div style="display:flex; gap:8px; margin-top:8px">
            <button class="btn" onclick="selectGame('${g.id}')">Chơi</button>
            <button class="btn ghost" onclick="openHelp('${g.id}')">?</button>
          </div>
        `;
        root.gamesGrid.appendChild(card);
      });

    }
    // <-- added function to fix "selectGame is not defined" error
    function selectGame(gameId){
      // Support quick play for games that have playable implementations
      if(gameId === 'tictactoe'){
        quickPlay(gameId);
        return;
      }
      if(gameId === 'connect4'){
        quickPlay(gameId);
        return;
      }
      alert('Game này hiện đang là demo UI. Chọn Tic Tac Toe hoặc Connect 4 để chơi ngay.');
    }

    /* ---------- Navigation handlers ---------- */
    document.getElementById('quickPlayBtn').addEventListener('click', ()=> {
      // default quick play picks first game (tictactoe)
      quickPlay('tictactoe');
    });
    document.getElementById('createRoomBtn').addEventListener('click', ()=> {
      openCreateRoom(); // mở modal cho phép chọn game
    });
    document.getElementById('statsBtn').addEventListener('click', ()=> {
      renderStatsView(); showView('stats');
    });
    document.getElementById('backToHomeBtn').addEventListener('click', ()=> showView('home'));
    document.getElementById('clearStatsBtn').addEventListener('click', ()=> {
      if(confirm('Xoá toàn bộ thống kê?')) clearStats();
    });

    /* ---------- Create room modal ---------- */
    function openCreateRoom(gameId){
      const defaultGameId = gameId || (GAMES[0] && GAMES[0].id) || 'tictactoe';
      const startGame = GAMES.find(g => g.id === defaultGameId) || GAMES[0];

      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      overlay.innerHTML = `
        <div class="panel-modal">
          <h3 id="createModalTitle">Tạo phòng — ${startGame.name}</h3>

          <div style="margin-top:8px">
            <label class="small muted">Tên bạn</label>
            <input id="createName" placeholder="User123" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);margin-top:6px;background:transparent;color:inherit" />
          </div>

          <div style="margin-top:8px">
            <label class="small muted">Chọn game</label>
            <select id="selectGame" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);margin-top:6px;background:transparent;color:inherit">
              ${GAMES.map(g=>`<option value="${g.id}" ${g.id === defaultGameId ? 'selected' : ''}>${g.name}</option>`).join('')}
            </select>
          </div>

          <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
            <button class="btn ghost" id="cancelCreate">Huỷ</button>
            <button class="btn" id="confirmCreate">Tạo phòng</button>
          </div>
        </div>
      `;
      overlay.onclick = (e)=>{ if(e.target === overlay) overlay.remove(); };
      document.body.appendChild(overlay);

      const selectEl = document.getElementById('selectGame');
      const titleEl = document.getElementById('createModalTitle');
      // cập nhật tiêu đề khi đổi select
      selectEl.onchange = ()=> {
        const g = GAMES.find(x => x.id === selectEl.value);
        if(g) titleEl.textContent = `Tạo phòng — ${g.name}`;
      };

      document.getElementById('cancelCreate').onclick = ()=> overlay.remove();
      document.getElementById('confirmCreate').onclick = ()=>{
        const name = (document.getElementById('createName').value || 'Player').trim();
        const chosen = (document.getElementById('selectGame').value) || defaultGameId;
        const r = createRoom(chosen, name);
        overlay.remove();
        openRoom(r.id);
      };
    }

    function promptJoin(id){
      const name = prompt('Tên bạn (local demo):', 'Guest');
      if(!name) return;
      const ok = joinRoom(id, name);
      if(ok) openRoom(id);
      else alert('Không thể tham gia phòng này.');
    }

    /* ---------- Open room / lobby ---------- */
    function openRoom(roomId){
      const room = ROOMS[roomId];
      if(!room){ alert('Phòng không tồn tại'); return; }
      showView('game');
      root.currentGameLabel.textContent = room.gameId;
      // render lobby
      root.lobbyArea.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Phòng #${room.id}</strong> • ${room.gameId}</div>
          <div class="small muted">Host: ${room.host}</div>
        </div>
        <div class="lobby-players" id="lobbyPlayers"></div>
        <div style="margin-top:8px">
          <button class="btn" id="startBtn">Bắt đầu trò chơi</button>
          <button class="btn ghost" id="leaveBtn">Rời phòng</button>
        </div>
      `;
      root.lobbyArea.appendChild(wrap);
      function refreshPlayers(){
        const el = document.getElementById('lobbyPlayers');
        el.innerHTML = '';
        room.players.forEach(p=>{
          const pEl = document.createElement('div'); pEl.className='player-pill';
          pEl.textContent = p;
          el.appendChild(pEl);
        });
      }
      refreshPlayers();
      document.getElementById('startBtn').onclick = ()=>{
        // For demo: start the appropriate game based on room.gameId
        const gameId = room.gameId;
        if(room.players.length >= 2){
          if(gameId === 'tictactoe') startTicTacToe({mode:'pvp', players:room.players.slice(0,2)});
          else if(gameId === 'connect4') startConnect4({mode:'pvp', players:room.players.slice(0,2)});
          else alert('Game này hiện đang là demo UI.');
        } else {
          // Ask to play vs AI
          if(confirm('Chỉ có 1 người trong phòng. Bắt đầu với AI?')){
            if(gameId === 'tictactoe') startTicTacToe({mode:'pva', players:[room.host,'AI']});
            else if(gameId === 'connect4') startConnect4({mode:'pva', players:[room.host,'AI']});
            else alert('Game này hiện đang là demo UI.');
          }
        }
      };
      document.getElementById('leaveBtn').onclick = ()=>{
        delete ROOMS[roomId];
        renderRooms();
        showView('home');
      };
    }

    /* ---------- Quick play ---------- */
    function quickPlay(gameId){
      // Quick play supports tictactoe and connect4 in demo
      if(gameId === 'tictactoe'){
        showView('game');
        root.currentGameLabel.textContent = 'Tic Tac Toe';
        startTicTacToe({mode:'pva', players:[root.usernameEl.textContent, 'AI']});
        return;
      }
      if(gameId === 'connect4'){
        showView('game');
        root.currentGameLabel.textContent = 'Connect 4';
        startConnect4({mode:'pva', players:[root.usernameEl.textContent, 'AI']});
        return;
      }
      alert('Game này đang demo cho UI. Chọn Tic Tac Toe hoặc Connect 4 để chơi ngay.');
    }

    /* ---------- TICTACTOE Implementation ---------- */
    function startTicTacToe(opts){
      // opts: {mode: 'pva'|'pvp', players:[name1,name2]}
      root.lobbyArea.innerHTML = '';
      root.turnLabel.textContent = '';
      const area = document.createElement('div');
      area.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>${opts.mode === 'pvp' ? '1 vs 1' : 'Vs AI'}</strong></div>
          <div class="small muted">Players: ${opts.players.join(' • ')}</div>
        </div>
        <div id="tttBoardWrap"></div>
        <div style="margin-top:12px;display:flex;gap:8px">
          <button class="btn ghost" id="restartBtn">Chơi lại</button>
          <button class="btn ghost" id="exitGameBtn">Thoát</button>
        </div>
      `;
      root.lobbyArea.appendChild(area);

      const boardWrap = document.getElementById('tttBoardWrap');
      // render board UI
      const boardEl = document.createElement('div');
      boardEl.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
          <div class="meta"><div class="small muted">Lượt:</div><div id="activePlayer" style="font-weight:800;margin-left:8px">-</div></div>
          <div class="meta"><div class="small muted">Kết quả:</div><div id="resultLabel" style="font-weight:800;margin-left:8px">-</div></div>
        </div>
        <div id="boardRoot" style="margin-top:12px"></div>
      `;
      boardWrap.appendChild(boardEl);

      // Game state
      const state = {
        cells: Array(9).fill(null), // 'X' or 'O'
        turn: 'X', // X always starts
        playerFor: { X: opts.players[0], O: (opts.players[1] || 'AI') },
        mode: opts.mode,
        over: false
      };

      function renderBoard(){
        const rootBoard = document.getElementById('boardRoot');
        rootBoard.innerHTML = '';
        const grid = document.createElement('div'); grid.className = 'board';
        state.cells.forEach((c,i)=>{
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.idx = i;
          cell.innerHTML = c ? (c === 'X' ? '&#10006;' : '&#9679;') : '';
          cell.onclick = ()=> onCellClick(i);
          grid.appendChild(cell);
        });
        rootBoard.appendChild(grid);
        document.getElementById('activePlayer').textContent = `${state.playerFor[state.turn]} (${state.turn})`;
      }

      function onCellClick(idx){
        if(state.over) return;
        if(state.cells[idx]) return;
        // if PvA and it's O's turn and O is AI: block
        if(state.mode === 'pva' && state.turn === 'O' && state.playerFor.O === 'AI') return;
        makeMove(idx);
      }

      function makeMove(idx){
        if(state.over) return;
        if(state.cells[idx]) return;
        state.cells[idx] = state.turn;
        const winner = checkWinner(state.cells);
        if(winner || isBoardFull(state.cells)){
          state.over = true;
          renderBoard();
          if(winner){
            const winnerPlayer = state.playerFor[winner];
            document.getElementById('resultLabel').textContent = `${winnerPlayer} thắng!`;
            // If local user is the first player, treat result accordingly
            // For demo, consider username is root.usernameEl.textContent
            const un = root.usernameEl.textContent;
            if(winnerPlayer === un) recordResult('tictactoe','win');
            else if(winnerPlayer === 'AI') recordResult('tictactoe','lose');
            else recordResult('tictactoe','lose');
          } else {
            document.getElementById('resultLabel').textContent = `Hoà`;
            recordResult('tictactoe','draw');
          }
        } else {
          // switch turn
          state.turn = (state.turn === 'X') ? 'O' : 'X';
          renderBoard();
          // if AI's turn, compute move
          if(state.mode === 'pva' && state.turn === 'O' && state.playerFor.O === 'AI'){
            setTimeout(()=> {
              const aiMove = getBestMove(state.cells, 'O');
              makeMove(aiMove);
            }, 300);
          }
        }
      }

      document.getElementById('restartBtn').onclick = ()=>{
        state.cells = Array(9).fill(null); state.turn='X'; state.over=false;
        document.getElementById('resultLabel').textContent = '-';
        renderBoard();
      };
      document.getElementById('exitGameBtn').onclick = ()=> showView('home');

      // initial render
      document.getElementById('resultLabel').textContent = '-';
      renderBoard();
      // If AI starts (not in our design), could call AI...
    }

    /* ---------- TicTacToe helpers (winner, minimax AI) ---------- */
    function checkWinner(cells){
      const lines = [
        [0,1,2],[3,4,5],[6,7,8],
        [0,3,6],[1,4,7],[2,5,8],
        [0,4,8],[2,4,6]
      ];
      for(const [a,b,c] of lines){
        if(cells[a] && cells[a] === cells[b] && cells[a] === cells[c]) return cells[a];
      }
      return null;
    }
    function isBoardFull(cells){ return cells.every(Boolean); }

    // Minimax for perfect play (small board)
    function getBestMove(cells, player){
      // player is 'O' (AI) in our usage
      const opponent = player === 'X' ? 'O' : 'X';
      // Score: +10 for AI win, -10 for loss, 0 draw
      function minimax(board, depth, isMaximizing){
        const win = checkWinner(board);
        if(win === player) return 10 - depth;
        if(win === opponent) return depth - 10;
        if(isBoardFull(board)) return 0;

        if(isMaximizing){
          let best = -Infinity;
          for(let i=0;i<9;i++){
            if(!board[i]){
              board[i] = player;
              const score = minimax(board, depth+1, false);
              board[i] = null;
              if(score > best) best = score;
            }
          }
          return best;
        } else {
          let best = Infinity;
          for(let i=0;i<9;i++){
            if(!board[i]){
              board[i] = opponent;
              const score = minimax(board, depth+1, true);
              board[i] = null;
              if(score < best) best = score;
            }
          }
          return best;
        }
      }

      let bestScore = -Infinity, move = -1;
      for(let i=0;i<9;i++){
        if(!cells[i]){
          cells[i] = player;
          const score = minimax(cells, 0, false);
          cells[i] = null;
          if(score > bestScore){ bestScore = score; move = i; }
        }
      }
      // fallback: first empty
      if(move === -1) move = cells.findIndex(c => !c);
      return move;
    }

    /* ---------- CONNECT 4 Implementation (moved from <style>) ---------- */
    function startConnect4(opts){
      // opts: {mode: 'pva'|'pvp', players:[name1,name2]}
      root.lobbyArea.innerHTML = '';
      root.turnLabel.textContent = '';
      const area = document.createElement('div');
      area.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>${opts.mode === 'pvp' ? '1 vs 1' : 'Vs AI'}</strong></div>
          <div class="small muted">Players: ${opts.players.join(' • ')}</div>
        </div>
        <div id="c4BoardWrap"></div>
        <div style="margin-top:12px;display:flex;gap:8px">
          <button class="btn ghost" id="restartC4Btn">Chơi lại</button>
          <button class="btn ghost" id="exitC4Btn">Thoát</button>
        </div>
      `;
      root.lobbyArea.appendChild(area);

      const boardWrap = document.getElementById('c4BoardWrap');

      // state
      const state = {
        cells: Array(42).fill(null), // 'X' or 'O'
        turn: 'X', // X starts
        playerFor: { X: opts.players[0], O: (opts.players[1] || 'AI') },
        mode: opts.mode,
        over: false
      };

      function renderBoard(){
        boardWrap.innerHTML = '';
        const info = document.createElement('div');
        info.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
            <div class="meta"><div class="small muted">Lượt:</div><div id="c4ActivePlayer" style="font-weight:800;margin-left:8px">-</div></div>
            <div class="meta"><div class="small muted">Kết quả:</div><div id="c4ResultLabel" style="font-weight:800;margin-left:8px">-</div></div>
          </div>
        `;
        boardWrap.appendChild(info);

        // top controls aligned as a grid so arrows line up exactly with columns
        const topGrid = document.createElement('div');
        topGrid.style.display = 'grid';
        topGrid.style.gridTemplateColumns = 'repeat(7, 72px)';
        topGrid.style.gap = '8px';
        topGrid.style.justifyContent = 'center';
        topGrid.style.marginBottom = '8px';
        for(let c=0;c<7;c++){
          const btn = document.createElement('button');
          btn.className = 'btn ghost';
          btn.style.padding = '6px 8px';
          btn.style.width = '72px';
          btn.textContent = '↓';
          btn.onclick = ()=> onColumnClick(c);
          topGrid.appendChild(btn);
        }
        boardWrap.appendChild(topGrid);

        const grid = document.createElement('div');
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = 'repeat(7, 72px)';
        grid.style.gridAutoRows = '56px';
        grid.style.gap = '8px';
        grid.style.justifyContent = 'center';

        // render cells (row 0 top -> row 5 bottom)
        for(let r=0;r<6;r++){
          for(let c=0;c<7;c++){
            const idx = r*7 + c;
            const el = document.createElement('div');
            el.className = 'cell';
            el.style.width = '72px';
            el.style.height = '56px';
            el.style.borderRadius = '8px';
            el.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02))';
            el.style.fontSize = '28px';
            el.style.fontWeight = '800';
            el.style.display = 'flex';
            el.style.alignItems = 'center';
            el.style.justifyContent = 'center';
            const v = state.cells[idx];
            if(v) el.innerHTML = v === 'X' ? '&#10006;' : '&#9679;';
            grid.appendChild(el);
          }
        }
        boardWrap.appendChild(grid);
        document.getElementById('c4ActivePlayer').textContent = `${state.playerFor[state.turn]} (${state.turn})`;
      }

      function onColumnClick(col){
        if(state.over) return;
        // block if PvA and it's AI's turn
        if(state.mode === 'pva' && state.turn === 'O' && state.playerFor.O === 'AI') return;
        const dropIdx = dropPiece(state.cells, col, state.turn);
        if(dropIdx === -1) return; // column full
        afterMove();
      }

      function afterMove(){
        const win = checkWinnerConnect4(state.cells);
        if(win || isBoardFullConnect4(state.cells)){
          state.over = true;
          renderBoard();
          if(win){
            const winnerPlayer = state.playerFor[win];
            document.getElementById('c4ResultLabel').textContent = `${winnerPlayer} thắng!`;
            const un = root.usernameEl.textContent;
            if(winnerPlayer === un) recordResult('connect4','win');
            else if(winnerPlayer === 'AI') recordResult('connect4','lose');
            else recordResult('connect4','lose');
          } else {
            document.getElementById('c4ResultLabel').textContent = 'Hoà';
            recordResult('connect4','draw');
          }
          return;
        }

        // switch turn
        state.turn = (state.turn === 'X') ? 'O' : 'X';
        renderBoard();

        // AI move
        if(state.mode === 'pva' && state.turn === 'O' && state.playerFor.O === 'AI'){
          setTimeout(()=>{
            const aiMove = getBestMoveConnect4(state.cells, 'O');
            dropPiece(state.cells, aiMove, 'O');
            afterMove();
          }, 300);
        }
      }

      document.getElementById('restartC4Btn').onclick = ()=>{
        state.cells = Array(42).fill(null); state.turn='X'; state.over=false;
        const lbl = document.getElementById('c4ResultLabel');
        if(lbl) lbl.textContent = '-';
        renderBoard();
      };
      document.getElementById('exitC4Btn').onclick = ()=> showView('home');

      // initial render
      const lbl = document.getElementById('c4ResultLabel');
      if(lbl) lbl.textContent = '-';
      renderBoard();
    }

    function dropPiece(board, col, player){
      // returns index where piece landed or -1 if col full
      for(let r=5;r>=0;r--){
        const idx = r*7 + col;
        if(!board[idx]){ board[idx] = player; return idx; }
      }
      return -1;
    }

    function isBoardFullConnect4(board){ return board.every(Boolean); }

    function checkWinnerConnect4(board){
      // check all four directions for 4-in-a-row
      // horizontal
      for(let r=0;r<6;r++){
        for(let c=0;c<4;c++){
          const a = r*7 + c, b = r*7 + c+1, d = r*7 + c+2, e = r*7 + c+3;
          if(board[a] && board[a] === board[b] && board[a] === board[d] && board[a] === board[e]) return board[a];
        }
      }
      // vertical
      for(let c=0;c<7;c++){
        for(let r=0;r<3;r++){
          const a = r*7 + c, b = (r+1)*7 + c, d = (r+2)*7 + c, e = (r+3)*7 + c;
          if(board[a] && board[a] === board[b] && board[a] === board[d] && board[a] === board[e]) return board[a];
        }
      }
      // diag down-right
      for(let r=0;r<3;r++){
        for(let c=0;c<4;c++){
          const a = r*7 + c, b = (r+1)*7 + c+1, d = (r+2)*7 + c+2, e = (r+3)*7 + c+3;
          if(board[a] && board[a] === board[b] && board[a] === board[d] && board[a] === board[e]) return board[a];
        }
      }
      // diag up-right
      for(let r=3;r<6;r++){
        for(let c=0;c<4;c++){
          const a = r*7 + c, b = (r-1)*7 + c+1, d = (r-2)*7 + c+2, e = (r-3)*7 + c+3;
          if(board[a] && board[a] === board[b] && board[a] === board[d] && board[a] === board[e]) return board[a];
        }
      }
      return null;
    }

    // Simple minimax + heuristic for Connect4 with alpha-beta and depth limit
    function getBestMoveConnect4(board, player){
      const MAX_DEPTH = 5; // tradeoff: higher -> stronger but slower
      const opponent = player === 'X' ? 'O' : 'X';

      function scoreWindow(window, player){
        const opp = player === 'X' ? 'O' : 'X';
        const countP = window.filter(x=>x===player).length;
        const countO = window.filter(x=>x===opp).length;
        const countEmpty = window.filter(x=>!x).length;
        if(countP === 4) return 100000;
        if(countP === 3 && countEmpty ===1) return 100;
        if(countP === 2 && countEmpty ===2) return 10;
        if(countO === 3 && countEmpty ===1) return -80;
        if(countO === 2 && countEmpty ===2) return -10;
        return 0;
      }

      function evaluate(board, player){
        let score = 0;
        // center column preference
        const centerArray = [];
        for(let r=0;r<6;r++) centerArray.push(board[r*7 + 3]);
        const centerCount = centerArray.filter(x=>x===player).length;
        score += centerCount * 6;

        // horizontal windows
        for(let r=0;r<6;r++){
          for(let c=0;c<4;c++){
            const window = [board[r*7+c], board[r*7+c+1], board[r*7+c+2], board[r*7+c+3]];
            score += scoreWindow(window, player);
          }
        }
        // vertical
        for(let c=0;c<7;c++){
          for(let r=0;r<3;r++){
            const window = [board[r*7+c], board[(r+1)*7+c], board[(r+2)*7+c], board[(r+3)*7+c]];
            score += scoreWindow(window, player);
          }
        }
        // diag down-right
        for(let r=0;r<3;r++){
          for(let c=0;c<4;c++){
            const window = [board[r*7+c], board[(r+1)*7+c+1], board[(r+2)*7+c+2], board[(r+3)*7+c+3]];
            score += scoreWindow(window, player);
          }
        }
        // diag up-right
        for(let r=3;r<6;r++){
          for(let c=0;c<4;c++){
            const window = [board[r*7+c], board[(r-1)*7+c+1], board[(r-2)*7+c+2], board[(r-3)*7+c+3]];
            score += scoreWindow(window, player);
          }
        }
        return score;
      }

      function validCols(board){
        const cols=[];
        for(let c=0;c<7;c++) if(!board[c]) cols.push(c); // top row empty means column available
        return cols;
      }

      function cloneBoard(b){ return b.slice(); }

      function minimax(board, depth, alpha, beta, maximizing){
        const win = checkWinnerConnect4(board);
        if(win === player) return {score: 1000000 - depth};
        if(win === opponent) return {score: -1000000 + depth};
        if(isBoardFullConnect4(board) || depth >= MAX_DEPTH) return {score: evaluate(board, player)};

        const colsOrder = [3,2,4,1,5,0,6];
        if(maximizing){
          let value = -Infinity; let col = colsOrder[0];
          for(const c of colsOrder){
            // try drop
            const topIdx = c; if(board[topIdx]) continue;
            const b2 = cloneBoard(board);
            dropPiece(b2, c, player);
            const res = minimax(b2, depth+1, alpha, beta, false);
            if(res.score > value){ value = res.score; col = c; }
            alpha = Math.max(alpha, value);
            if(alpha >= beta) break;
          }
          return {score: value, col};
        } else {
          let value = Infinity; let col = colsOrder[0];
          for(const c of colsOrder){
            const topIdx = c; if(board[topIdx]) continue;
            const b2 = cloneBoard(board);
            dropPiece(b2, c, opponent);
            const res = minimax(b2, depth+1, alpha, beta, true);
            if(res.score < value){ value = res.score; col = c; }
            beta = Math.min(beta, value);
            if(alpha >= beta) break;
          }
          return {score: value, col};
        }
      }

      const best = minimax(board, 0, -Infinity, Infinity, true);
      // fallback pick center-most valid
      if(typeof best.col === 'number') return best.col;
      const fallback = validCols(board)[0];
      return (typeof fallback === 'number') ? fallback : 0;
    }



    /* ---------- REVERSI (Othello) Implementation ---------- */
    function startReversi(opts){
      // opts: {mode: 'pva'|'pvp', players:[name1,name2]}
      root.lobbyArea.innerHTML = '';
      root.turnLabel.textContent = '';
      const area = document.createElement('div');
      area.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>${opts.mode === 'pvp' ? '1 vs 1' : 'Vs AI'}</strong></div>
          <div class="small muted">Players: ${opts.players.join(' • ')}</div>
        </div>
        <div id="reversiBoardWrap"></div>
        <div style="margin-top:12px;display:flex;gap:8px">
          <button class="btn ghost" id="restartReBtn">Chơi lại</button>
          <button class="btn ghost" id="exitReBtn">Thoát</button>
        </div>
      `;
      root.lobbyArea.appendChild(area);
      const wrap = document.getElementById('reversiBoardWrap');

      const SIZE = 8;
      const state = {
        board: initReversiBoard(),
        turn: 'X', // X goes first
        playerFor: { X: opts.players[0], O: (opts.players[1] || 'AI') },
        mode: opts.mode,
        over: false
      };

      function initReversiBoard(){
        const b = Array(SIZE*SIZE).fill(null);
        // Standard initial position
        b[3*SIZE + 3] = 'O';
        b[3*SIZE + 4] = 'X';
        b[4*SIZE + 3] = 'X';
        b[4*SIZE + 4] = 'O';
        return b;
      }

      function render(){
        wrap.innerHTML = '';
        const info = document.createElement('div');
        info.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
            <div class="meta"><div class="small muted">Lượt:</div><div id="reActivePlayer" style="font-weight:800;margin-left:8px">-</div></div>
            <div class="meta"><div class="small muted">Kết quả:</div><div id="reResultLabel" style="font-weight:800;margin-left:8px">-</div></div>
          </div>
        `;
        wrap.appendChild(info);

        const boardEl = document.createElement('div');
        boardEl.style.display = 'grid';
        boardEl.style.gridTemplateColumns = `repeat(${SIZE}, 56px)`;
        boardEl.style.gridGap = '6px';
        boardEl.style.justifyContent = 'center';
        boardEl.style.marginTop = '12px';

        const valid = getValidMoves(state.board, state.turn);

        for(let r=0;r<SIZE;r++){
          for(let c=0;c<SIZE;c++){
            const idx = r*SIZE + c;
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.style.width = '56px';
            cell.style.height = '56px';
            cell.style.borderRadius = '8px';
            cell.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.15), rgba(255,255,255,0.02))';
            cell.style.display = 'flex';
            cell.style.alignItems = 'center';
            cell.style.justifyContent = 'center';
            cell.style.position = 'relative';
            cell.style.cursor = 'pointer';
            cell.style.boxSizing = 'border-box';
            cell.style.border = '1px solid rgba(255,255,255,0.02)';

            const v = state.board[idx];
            if(v){
              const disc = document.createElement('div');
              disc.style.width = '40px';
              disc.style.height = '40px';
              disc.style.borderRadius = '50%';
              disc.style.boxShadow = 'inset 0 2px 4px rgba(0,0,0,0.4)';
              disc.style.display = 'flex';
              disc.style.alignItems = 'center';
              disc.style.justifyContent = 'center';
              disc.style.fontWeight = '800';
              disc.style.color = v === 'X' ? '#071022' : '#fff';
              disc.style.background = v === 'X' ? 'linear-gradient(180deg,#fef3c7,#f59e0b)' : 'linear-gradient(180deg,#111827,#374151)';
              cell.appendChild(disc);
            } else if(valid[idx]) {
              // show hint dot
              const dot = document.createElement('div');
              dot.style.width = '10px';
              dot.style.height = '10px';
              dot.style.borderRadius = '50%';
              dot.style.background = 'rgba(255,255,255,0.6)';
              dot.style.opacity = '0.9';
              cell.appendChild(dot);
            }

            cell.onclick = ()=> onCellClick(idx, !!valid[idx]);
            boardEl.appendChild(cell);
          }
        }

        const score = countScore(state.board);
        const scoreEl = document.createElement('div');
        scoreEl.style.marginTop = '10px';
        scoreEl.style.display = 'flex';
        scoreEl.style.justifyContent = 'center';
        scoreEl.style.gap = '12px';
        scoreEl.innerHTML = `<div class="pill">X: ${score.X}</div><div class="pill">O: ${score.O}</div>`;
        wrap.appendChild(boardEl);
        wrap.appendChild(scoreEl);

        document.getElementById('reActivePlayer').textContent = `${state.playerFor[state.turn]} (${state.turn})`;
      }

      function onCellClick(idx, isValid){
        if(state.over) return;
        if(!isValid) return;
        applyMove(state.board, idx, state.turn);
        proceedAfterMove();
      }

      function proceedAfterMove(){
        // check end conditions
        const opp = state.turn === 'X' ? 'O' : 'X';
        // switch turn
        state.turn = opp;
        const myValid = Object.keys(getValidMoves(state.board, state.turn)).length > 0;
        if(!myValid){
          // no moves for opponent -> check current player
          const curValid = Object.keys(getValidMoves(state.board, opp)).length > 0;
          if(!curValid){
            // game over
            state.over = true;
            render();
            finishGame();
            return;
          } else {
            // skip opponent turn, keep same player
            state.turn = opp === 'X' ? 'O' : 'X';
          }
        }

        render();

        // AI move if needed
        if(state.mode === 'pva' && state.playerFor[state.turn] === 'AI'){
          setTimeout(()=>{
            const mv = getBestMoveReversi(state.board, state.turn);
            if(typeof mv === 'number'){
              applyMove(state.board, mv, state.turn);
              proceedAfterMove();
            }
          }, 250);
        }
      }

      function finishGame(){
        const s = countScore(state.board);
        let resultText = '';
        const un = root.usernameEl.textContent;
        // interpret winner relative to local user (assume local user is X if named player1)
        let localIs = (state.playerFor.X === un) ? 'X' : ((state.playerFor.O === un) ? 'O' : null);
        if(s.X > s.O){
          resultText = `${state.playerFor.X} thắng!`;
          if(localIs === 'X') recordResult('reversi','win'); else if(localIs === 'O') recordResult('reversi','lose');
        } else if(s.O > s.X){
          resultText = `${state.playerFor.O} thắng!`;
          if(localIs === 'O') recordResult('reversi','win'); else if(localIs === 'X') recordResult('reversi','lose');
        } else {
          resultText = 'Hoà';
          recordResult('reversi','draw');
        }
        const lbl = document.getElementById('reResultLabel');
        if(lbl) lbl.textContent = resultText;
      }

      document.getElementById('restartReBtn').onclick = ()=>{
        state.board = initReversiBoard();
        state.turn = 'X';
        state.over = false;
        const lbl = document.getElementById('reResultLabel');
        if(lbl) lbl.textContent = '-';
        render();
      };
      document.getElementById('exitReBtn').onclick = ()=> showView('home');

      // initial render
      const lbl = document.getElementById('reResultLabel');
      if(lbl) lbl.textContent = '-';
      render();
    }

    // Reversi helpers
    const DIRS8 = [-8,-7,1,9,8,7,-1,-9]; // careful with row edges when using 1D
    function onBoard(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

    function indexToRC(idx){ return { r: Math.floor(idx/8), c: idx % 8 }; }
    function rcToIndex(r,c){ return r*8 + c; }

    function getValidMoves(board, player){
      const opp = player === 'X' ? 'O' : 'X';
      const moves = {};
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const idx = rcToIndex(r,c);
          if(board[idx]) continue;
          const flips = [];
          // check all 8 directions
          const directions = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]];
          for(const [dr,dc] of directions){
            let rr = r + dr, cc = c + dc;
            const line = [];
            while(onBoard(rr,cc) && board[rcToIndex(rr,cc)] === opp){
              line.push(rcToIndex(rr,cc));
              rr += dr; cc += dc;
            }
            if(line.length > 0 && onBoard(rr,cc) && board[rcToIndex(rr,cc)] === player){
              flips.push(...line);
            }
          }
          if(flips.length) moves[idx] = flips;
        }
      }
      return moves;
    }

    function applyMove(board, idx, player){
      const moves = getValidMoves(board, player);
      const flips = moves[idx];
      if(!flips) return false;
      board[idx] = player;
      for(const f of flips) board[f] = player;
      return true;
    }

    function countScore(board){
      const res = { X:0, O:0 };
      board.forEach(v=>{ if(v==='X') res.X++; else if(v==='O') res.O++; });
      return res;
    }

    // Simple AI: maximize flips, prefer corners
    function getBestMoveReversi(board, player){
      const moves = getValidMoves(board, player);
      const keys = Object.keys(moves).map(k=>parseInt(k,10));
      if(keys.length === 0) return null;
      const corners = new Set([0,7,56,63]);
      let best = keys[0], bestScore = -Infinity;
      for(const k of keys){
        const flips = moves[k].length;
        let score = flips;
        if(corners.has(k)) score += 100; // strong preference
        // small positional bonus: edges
        const {r,c} = indexToRC(k);
        if(r===0||r===7) score += 2;
        if(c===0||c===7) score += 2;
        if(score > bestScore){ bestScore = score; best = k; }
      }
      return best;
    }

    /* ---------- Override small navigation hooks to include Reversi ---------- */
    // allow selecting reversi quick-play
    function selectGame(gameId){
      if(gameId === 'tictactoe'){ quickPlay(gameId); return; }
      if(gameId === 'connect4'){ quickPlay(gameId); return; }
      if(gameId === 'reversi'){ quickPlay(gameId); return; }
      alert('Game này hiện đang là demo UI. Chọn Tic Tac Toe, Connect 4, hoặc Reversi để chơi ngay.');
    }

    // quickPlay include reversi
    function quickPlay(gameId){
      if(gameId === 'tictactoe'){ showView('game'); root.currentGameLabel.textContent = 'Tic Tac Toe'; startTicTacToe({mode:'pva', players:[root.usernameEl.textContent, 'AI']}); return; }
      if(gameId === 'connect4'){ showView('game'); root.currentGameLabel.textContent = 'Connect 4'; startConnect4({mode:'pva', players:[root.usernameEl.textContent, 'AI']}); return; }
      if(gameId === 'reversi'){ showView('game'); root.currentGameLabel.textContent = 'Reversi'; startReversi({mode:'pva', players:[root.usernameEl.textContent, 'AI']}); return; }
      alert('Game này đang demo cho UI. Chọn Tic Tac Toe, Connect 4, hoặc Reversi để chơi ngay.');
    }

    // ensure openRoom starts reversi when chosen
    function openRoom(roomId){
      const room = ROOMS[roomId];
      if(!room){ alert('Phòng không tồn tại'); return; }
      showView('game');
      root.currentGameLabel.textContent = room.gameId;
      // render lobby
      root.lobbyArea.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Phòng #${room.id}</strong> • ${room.gameId}</div>
          <div class="small muted">Host: ${room.host}</div>
        </div>
        <div class="lobby-players" id="lobbyPlayers"></div>
        <div style="margin-top:8px">
          <button class="btn" id="startBtn">Bắt đầu trò chơi</button>
          <button class="btn ghost" id="leaveBtn">Rời phòng</button>
        </div>
      `;
      root.lobbyArea.appendChild(wrap);
      function refreshPlayers(){
        const el = document.getElementById('lobbyPlayers');
        el.innerHTML = '';
        room.players.forEach(p=>{
          const pEl = document.createElement('div'); pEl.className='player-pill';
          pEl.textContent = p;
          el.appendChild(pEl);
        });
      }
      refreshPlayers();
      document.getElementById('startBtn').onclick = ()=>{
        const gameId = room.gameId;
        if(room.players.length >= 2){
          if(gameId === 'tictactoe') startTicTacToe({mode:'pvp', players:room.players.slice(0,2)});
          else if(gameId === 'connect4') startConnect4({mode:'pvp', players:room.players.slice(0,2)});
          else if(gameId === 'reversi') startReversi({mode:'pvp', players:room.players.slice(0,2)});
          else alert('Game này hiện đang là demo UI.');
        } else {
          if(confirm('Chỉ có 1 người trong phòng. Bắt đầu với AI?')){
            if(gameId === 'tictactoe') startTicTacToe({mode:'pva', players:[room.host,'AI']});
            else if(gameId === 'connect4') startConnect4({mode:'pva', players:[room.host,'AI']});
            else if(gameId === 'reversi') startReversi({mode:'pva', players:[room.host,'AI']});
            else alert('Game này hiện đang là demo UI.');
          }
        }
      };
      document.getElementById('leaveBtn').onclick = ()=>{
        delete ROOMS[roomId];
        renderRooms();
        showView('home');
      };
    }

    // expose reversi start for debugging
    window.startReversi = startReversi;

    /* ---------- Stats View render ---------- */
    function renderStatsView(){
      root.statsList.innerHTML = '';
      const st = STATS;
      const games = GAMES.map(g=>g.id);
      const total = st.total || 0;
      root.totalGamesEl.textContent = total;
      const wins = Object.values(st.wins || {}).reduce((a,b)=>a+(b||0),0);
      const losses = Object.values(st.losses || {}).reduce((a,b)=>a+(b||0),0);
      const winRate = total ? Math.round((wins/total)*100) : 0;
      root.winRateEl.textContent = winRate + '%';

      // create rows
      GAMES.forEach(g=>{
        const w = st.wins[g.id] || 0;
        const l = st.losses[g.id] || 0;
        const d = st.draws[g.id] || 0;
        const node = document.createElement('div');
        node.className = 'stat-row';
        node.innerHTML = `<div>
          <div style="font-weight:700">${g.name}</div>
          <div class="small muted">${g.desc}</div>
        </div>
        <div style="text-align:right">
          <div style="font-weight:800">${w}W • ${l}L • ${d}D</div>
          <div class="small muted">Tổng: ${w+l+d}</div>
        </div>`;
        root.statsList.appendChild(node);
      });
    }

    function refreshHeaderStats(){
      const st = STATS;
      const total = st.total || 0;
      const wins = Object.values(st.wins || {}).reduce((a,b)=>a+(b||0),0);
      const losses = Object.values(st.losses || {}).reduce((a,b)=>a+(b||0),0);
      const winRate = total ? Math.round((wins/total)*100) : 0;
      document.getElementById('user-stats').textContent = `Win: ${wins} • Lose: ${losses}`;
      root.totalGamesEl.textContent = total;
      root.winRateEl.textContent = winRate + '%';
    }

    /* ---------- small boot ---------- */
    (function init(){
      renderGameCards();
      renderRooms();
      renderStatsView();
      refreshHeaderStats();
      // username basic: allow change on avatar click
      root.avatarEl.onclick = ()=> {
        const n = prompt('Nhập tên hiển thị:', root.usernameEl.textContent);
        if(n){ root.usernameEl.textContent = n; root.avatarEl.textContent = n.trim().charAt(0).toUpperCase(); }
      };
      window.openRoom = openRoom;
      window.promptJoin = promptJoin;
      window.openCreateRoom = openCreateRoom;
      window.quickPlay = quickPlay;
      window.startConnect4 = startConnect4;
      // expose clear for debugging
      window.__WB = { STATS, ROOMS };
    })();

    function openHelp(gameId){
      const game = GAMES.find(x => x.id === gameId);

    const rules = {
      tictactoe: "Đánh theo lượt, ai tạo được hàng ngang/dọc/chéo 3 ký tự trước thì thắng.",
      connect4: "Thả quân vào cột, ai tạo được 4 quân liên tiếp thì thắng.",
      reversi: "Kẹp quân đối thủ để lật màu, cuối trận ai nhiều quân hơn thắng.",
      chessmini: "Luật tương tự cờ vua nhưng bàn nhỏ hơn.",
      coganh: "Bao vây để gánh quân đối phương.",
      uno: "Đánh theo màu/số, ai hết bài trước thắng."
    };

    root.overlayRoot.className = 'overlay';
    root.overlayRoot.innerHTML = `
      <div class="panel-modal">
        <h2>${game.name} — Hướng dẫn</h2>
        <p style="margin:10px 0 20px">${rules[gameId] || "Chưa có hướng dẫn."}</p>
        <button class="btn" onclick="closeHelp()">Đóng</button>
      </div>
    `;
  }

  function closeHelp(){
    root.overlayRoot.className = 'hidden';
    root.overlayRoot.innerHTML = '';
  }

  </script>
</body>
</html>